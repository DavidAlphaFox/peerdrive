- General
	- clean up guid/uuid/rev clash
		- we have DOC's which point to REV's
		- Doc's and Rev's are identified by UUID's (as defined in ISO/IEC 9834-8:2005)
		- generate valid uuids
			- v4 -> doc's
			- v5 -> rev's
		- stores are identified by their root doc UUID
	- rename volumes -> stores

- Server
	- replace MD5 hashes by SHA1-UUID's
	- File store improvements
		- garbage collection
		- automatically delete old revisions when disk full
	- add search engine
		- lucene
		- add query API (virtual collections)
	- add FUSE binding
		- read docs and revs like normal files
		- interpret collections and show as directories
		- direct access by UUID
	- network stores
		- network interface (remote interface)
		- network store stub
		- rev cache
	- automatically detect/mount stores
		- local stores when removable drive connected (inotify/WM_DEVICECHANGE)
		- network stores (bonjour)
	- API cleanup
		- Identifier naming
			- All identifiers are UUID's
			- Doc's are v4 UUIDs
			- Rev's are v5 UUIDs
			- Any other UUIDs are not accepted
		- consistent opcodes
		- consistent error handling
			- internally
			- on protocol level
		- stat: flags for requested information
	- support preliminary versions
	- support shared read/write access

- user interface
	- Use preliminary versions to save changes periodically
	- Additional file types
		- contacts
		- audio
		- video
	- improve collections
		- support email thread view
		- indicators
			- added (but not saved yet)
			- needs merge
			- may need replication
		- drag operations: copy as new document
	- possibility to cancel ongoing replication/synchronzation

- Libs
	- API cleanups
	- client side caching
		- revs
		- static stat info (dynamic infos on request)
	- command line interface

- Security
	- merging and synchronization
		- default
			- always ask when opening on merge condition (explicit merge)
			- no automatic synchronization
		- per store pair setting
			- system automatic sync
				- fast-forward (one-/two-way)
				- automatic 
			- user:
				- default conflict resolution strategy (ask/prefer/ff-only/auto merge)
	- access control
		- principle
			- attached to each uuid/rev
			- easy for file_store (reuse OS file permissions)
			- implementation specific because access control is context dependent
		- systems
			- unix permissions UID/GID/mask
			- ACL's
	- crpyto
		- revision signing
			- 'SIGN' part, signature of hashes, uti, mtime
		- encryption
			- 'ENCR' part
				- proxy links of encrypted parts
				- crypto method info
			- decryption cache in client for performance


================================ brainstorming ================================

- extend semantics
	- preliminary versions
		- support overwriting versions
			- just like "git commit --amend"
			- updating overwrites previous version
			- throw away temporary versions to keep history clean
			- will result in fake merge conditions
		- indicator for preliminary versions
			- will not be replicated/synced automatically
			- hint when merging manually
			- mitigate fake merge conditions
		- basis for autosave applications
			- periodically saves changes as preliminary versions
			- overwrite previous preliminary version
			- usefull to save intermediate merge result before checkpointing
			- finally save as non-preliminary checkpoint
		- accumulate multiple changes
			- could be used by command line / scripts
			- final commit after all changes are done
	- shared updates
		- allow dirty reads
		- only one writer per store and doc
		- usable to emulate old file model (simultanious read/write)

- simplified API
	- Data manipulation
		- peek(Rev, Stores) -- Open a rev for read only access
			- Rev: Rev to open
			- Stores: Optional set of stores where to search the rev. If empty
			          search on all mounted stores.
		- fork(Rev, Stores, Uti) -- Create a new document
			- Rev: Starting Rev of the new document (parent and initial
			       content). Use special Rev <<0:128>> when creating empty
				   document.
			- Stores: Optional set of stores where to search the Rev. If empty
			          try on all mounted stores where Rev exists.
			- Uti: Uti of the new document. If not given keep value of starting
			       revision.
		- update(Doc, Rev, Stores, Uti, Preliminary) -- Udate a document
			- Doc: Document to be updated
			- Rev: Current revision of the document which will be updated. At
			       least one store must point to this revision or the operation
				   will fail immediately. Any store which points to another
				   revision will not be updated.
			- Stores: Optional set of stores where to search the rev. If empty
			          search on all mounted stores.
			- Uti: Uti of the updated document. If not given keep the previous
			       value.
			- Preliminary: Make the new revision preliminary. Preliminary
			               predecessors are always overwritten, regardless of
						   this flag.
		- read(Handle, Part, Offset, Length)
			- Handle: as returned by open/fork/update
			- Part: FourCC
			- Offset, Length: guess what ;)
		- write(Handle, Part, Offset, Data)
			- Handle: as returned by fork/update
			- Part: FourCC
			- Offset
			- Data
		- commit(Handle, MergeRevs)
			- Handle: as returned by fork/update
			- MergeRevs: Additional parent revisions in case of a merge, empty
			             otherwise. If not given keep the previous value.
			- tristate result
				- success
					- at least one store has commited
				- retry
					- no store has comitted
					- at least one store has rejected due to conflicting revision
				- fail
					- all stores have rejected with hard errors
		- abort(Handle)
			- discard handle

	- Data distribution
		- sync(Doc, Stores) -- Perform a fast-forward sync
			- Doc: Document which should be unified among the stores
			- Stores: Optional set of stores where the document is
			          synchronized. If empty perform on all stores.
		- replicate_doc(Doc, Stores) -- Replicate a document to other stores
			- Doc: Unambigous document
			- Stores: Where to replicate to
		- replicate_rev(Rev, Stores) -- Replicate a revision to other stores
			- Rev: Revision, must be referenced on the destination store
			- Stores: Where to replicate to
		- delete_doc(Doc, Stores) -- Delete document
			- Doc: Document to be deleted
			- Stores: Optional set of stores where to delete the doc. If empty
			          delete on all mounted stores.
		- delete_rev(Rev, Stores) -- Delete revision
			- Rev: Revision to be deleted
			- Stores: Optional set of stores where to delete the rev. If empty
			          delete on all mounted stores.

