- General
	- clean up guid/uuid/rev clash
		- we have DOC's which point to REV's
		- Doc's and Rev's are identified by UUID's (as defined in ISO/IEC 9834-8:2005)
		- generate valid uuids
			- v4 -> doc's
			- v5 -> rev's
		- stores are identified by their root doc UUID
	- rename volumes -> stores

- Server
	- replace MD5 hashes by SHA1-UUID's
	- File store improvements
		- garbage collection
		- automatically delete old revisions when disk full
	- add search engine
		- lucene
		- add query API (virtual collections)
	- add FUSE binding
		- read docs and revs like normal files
		- interpret collections and show as directories
		- direct access by UUID
	- network stores
		- network interface (remote interface)
		- network store stub
		- rev cache
	- automatically detect/mount stores
		- local stores when removable drive connected (inotify/WM_DEVICECHANGE)
		- network stores (bonjour)
	- API cleanup
		- Identifier naming
			- All identifiers are UUID's
			- Doc's are v4 UUIDs
			- Rev's are v5 UUIDs
			- Any other UUIDs are not accepted
		- consistent opcodes
		- consistent error handling
			- internally
			- on protocol level
		- stat: flags for requested information
	- support preliminary versions
	- support shared read/write access

- user interface
	- Use preliminary versions to save changes periodically
	- Additional file types
		- contacts
		- audio
		- video
	- improve collections
		- support email thread view
		- indicators
			- added (but not saved yet)
			- needs merge
			- may need replication
		- drag operations: copy as new document
	- facility to store user meta data (window position, ...)
	- possibility to cancel ongoing replication/synchronzation

- Libs
	- API cleanups
	- client side caching
		- revs
		- static stat info (dynamic infos on request)
	- command line interface

- Security
	- merging and synchronization
		- default
			- always ask when opening on merge condition (explicit merge)
			- no automatic synchronization
		- per store pair setting
			- system automatic sync
				- fast-forward (one-/two-way)
				- automatic 
			- user:
				- default conflict resolution strategy (ask/prefer/ff-only/auto merge)
	- access control
		- principle
			- attached to each uuid/rev
			- easy for file_store (reuse OS file permissions)
			- implementation specific because access control is context dependent
		- systems
			- unix permissions UID/GID/mask
			- ACL's
	- crpyto
		- revision signing
			- 'SIGN' part, signature of hashes, uti, mtime
		- encryption
			- 'ENCR' part
				- proxy links of encrypted parts
				- crypto method info
			- decryption cache in client for performance


================================ brainstorming ================================

- extend semantics
	- preliminary versions
		- support overwriting versions
			- just like "git commit --amend"
			- updating overwrites previous version
			- throw away temporary versions to keep history clean
			- will result in fake merge conditions
		- indicator for preliminary versions
			- will not be replicated/synced automatically
			- hint when merging manually
			- mitigate fake merge conditions
		- basis for autosave applications
			- periodically saves changes as preliminary versions
			- overwrite previous preliminary version
			- usefull to save intermediate merge result before checkpointing
			- finally save as non-preliminary checkpoint
		- accumulate multiple changes
			- could be used by command line / scripts
			- final commit after all changes are done
	- shared updates
		- allow dirty reads
		- only one writer per store and doc
		- usable to emulate old file model (simultanious read/write)

- simplified API
	- Operations
		- open(Uuid, Mode, StartRev, Stores, Uti)
			- Uuid
				- Doc or Rev
				- ignored in case of creating
			- Mode
				- overwrite?
				- read/write/readwrite/create
					- create implies readwrite
					- Uuid must be a doc if writing is requested
				- fail on any/last store
			- StartRev:
				- starting Rev when writing, ignored when just reading
				- special Rev when creating empty document
			- Stores
				- set of stores where the operation should be performed
				- optional, if not given then done on all mounted stores
			- Uti:
				- set Uti of new version
				- optional, if not given keep previous value
		- read(Handle, Part, Offset, Length)
			- Handle: as returned by open
			- Part: FourCC
			- Offset, Length: guess what ;)
		- write(Handle, Part, Offset, Data)
			- Handle: as returned by open
			- Part: FourCC
			- Offset
			- Data
		- commit(Handle, OtherRevs)
			- Handle: as returned by open
			- OtherRevs: Additional parent revisions in case of a merge, empty otherwise
			- may fail on some stores
		- abort(Handle)
			- discard handle

