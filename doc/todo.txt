- General
	- clean up guid/uuid/rev clash
		- we have DOC's which point to REV's
		- Doc's and Rev's are identified by UUID's (as defined in ISO/IEC 9834-8:2005)
		- generate valid uuids
			- v4 -> doc's
			- v5 -> rev's
		- stores are identified by their root doc UUID
	- rename volumes -> stores

- Server
	- File store improvements
		- garbage collection
		- automatically delete old revisions when disk full
	- add search engine
		- lucene
		- add query API (virtual collections)
	- add FUSE binding
		- read docs and revs like normal files
		- interpret collections and show as directories
		- direct access by UUID
	- network stores
		- network interface (remote interface)
		- network store stub
		- rev cache
	- automatically detect/mount stores
		- local stores when removable drive connected (inotify/WM_DEVICECHANGE)
		- network stores (bonjour)
	- API cleanup
		- Identifier naming
			- All identifiers are UUID's
			- Doc's are v4 UUIDs
			- Rev's are v5 UUIDs
			- Any other UUIDs are not accepted
		- consistent opcodes
		- consistent error handling
			- internally
			- on protocol level
		- stat: flags for requested information
	- support preliminary versions
	- support shared read/write access

- user interface
	- Use preliminary versions to save changes periodically
	- Additional file types
		- contacts
		- audio
		- video
	- improve collections
		- support email thread view
		- indicators
			- added (but not saved yet)
			- needs merge
			- may need replication
		- drag operations: copy as new document
	- possibility to cancel ongoing replication/synchronzation

- Libs
	- API cleanups
	- client side caching
		- revs
		- static stat info (dynamic infos on request)
	- command line interface

- Security
	- merging and synchronization
		- default
			- always ask when opening on merge condition (explicit merge)
			- no automatic synchronization
		- per store pair setting
			- system automatic sync
				- fast-forward (one-/two-way)
				- automatic 
			- user:
				- default conflict resolution strategy (ask/prefer/ff-only/auto merge)
	- access control
		- principle
			- attached to each uuid/rev
			- easy for file_store (reuse OS file permissions)
			- implementation specific because access control is context dependent
		- systems
			- unix permissions UID/GID/mask
			- ACL's
	- crpyto
		- revision signing
			- 'SIGN' part, signature of hashes, uti, mtime
		- encryption
			- 'ENCR' part
				- proxy links of encrypted parts
				- crypto method info
			- decryption cache in client for performance


================================ brainstorming ================================

- extend semantics
	- shared updates
		- allow dirty reads
		- only one writer per store and doc
		- usable to emulate old file model (simultanious read/write)

