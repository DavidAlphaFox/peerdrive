
In PeerDrive the documents are stored in so called "stores". Each document is
uniquely identified by a 128 bit random number (DId), where the document/DId
can simultaneously live in more than one store. Each store maintains a mapping
of DIds to the latest revision of the document (plus zero or more preliminary
revisions). The actual content is stored in revisions and each revision is
identified by the hash of its content called RId.

At the basic level each revision consists of the following:

	- a set of flags
		- sticky flag
		- possibly other flags in the future
	- one or more "parts", each identified by a FourCC and containing a blob
	- a type code, specifying the format of the document (encoded as a Uniform
	  Type Identifier [UTI])
	- a creator code, denoting the application which created the revision
	  (encoded as a reverse-DNS string)
	- the modification time (microseconds since epoch, UTC)
	- a list of it's preceding revision(s) (parents),
	- all document/revision links, extracted from all parts
		- list of document links
		- list of revision links

This basic level is sufficient to store and retrieve arbitrary data, preserve
the history of changes to a document and also replicate and synchronize
documents between multiple stores. It also stores all necessary information to
link to other documents/revisions, independent of the actual link encoding in
one of the parts.


Binary object representation
============================

To compute the hash of a revision a common binary representation is needed.
All values are encoded as little endian...

uint32           .. Flags (0: Sticky, 1..31: Reserved [0])
uint32           .. PartsCount
	char[4]      .. FourCC
	uint128      .. SHA1 hash of part content (initial 16 bytes)
uint32           .. ParentsCount
	uint128      .. Parent object
uint64           .. Mtime (UTC unix time in microsecons)
uint32           .. Type code string length
	char[]       .. Type code
uint32           .. Creator code string length
	char[]       .. Creator code
uint32           .. DocLinkCount
	uint128      .. Document link
uint32           .. RevLinkCount
	uint128      .. Revision link


Well known part FourCCs
=======================

In PeerDrive the following part FourCCs are currently defined:

	- 'META': standardized, extensible meta data
	- 'FILE': byte stream (POSIX file content)
	- 'PDSD': structured content (PeerDrive Structured Data)

The data in 'META' and 'PDSD' is semantically similar to JSON. See below for
its definition and binary representation. The 'FILE' part is not interpreted by
the PeerDrive server. Other part FourCC will be rejected.


Document linking
================

Each document is treated completely independent of any other document. For
navigational access there can be directed links between them. As entry point to
the link chain there is a root document in each store, just like the root
directory in file systems.

There are two types of links in PeerDrive:

	- Document link: points to a document
	- Revision link: points to a revision

In essence PeerDrive links are like symbolic links in the meaning that they
symbolically refer to another document/revision. But they are also like hard
links in the sense that they are independent of the target's location, even
across stores.

To make the document linking independent from the actual encoding the links are
stored as meta data in each revision. They are extracted from known parts
(currently 'META' and 'PDSD') when a new revision is created.


Garbage collection
==================

Even though documents and revisions can be deleted explicitly they are normally
garbage collected implicitly. When there is no path from the root document of a
store to a certain document/revision then it is eligible for garbage
collection. The path is formed by links in the revision meta data (Doc- and
Rev-links) and the parent pointers of each revision.

This garbage collection scheme will keep documents alive as long as there is
any revision pointing to the document, even if none of them is current revision
of a document. In other words it would still be possible to open or update a
document which is not reachable by any current document revision. Stores should
prevent updates to such documents for a consistent user experience.

There is only one exception to the garbage collection rules above: newly
created documents. It is guaranteed that new documents are exempted from
garbage collection as long as the handle which committed the initial version is
kept open.

The rationale behind this exception is that new documents cannot be linked
before they are committed for the first time, simply because they don't exist
yet. This makes it impossible to satisfy the reachability criterion of the
garbage collector. By keeping the document handle open the creating application
can safely add a document link to the new document after committing the initial
version.


PeerDrive Structured Data
=========================

The data in the 'PDSD' and 'META' parts of a revision has a defined semantics
and binary representation.

Semantics
---------

PeerDrive can represent the following data types:
	- Number
		- Integer: 8..64 bits, signed/unsigned
		- Floating point: float/double
	- String: Unicode, Utf-8
	- Boolean
	- Link
		- Document link
		- Revision link
	- List: ordered sequence of values (any PeerDrive data type)
	- Dictionary: unordered sequence of key value pairs where
		- the key is a string,
		- and the value is of any PeerDrive data type

Binary representation
---------------------

All data stored as little endian. The following is no strict EBNF but you
should get the idea...

PDSD = value

value = dict | list | string | bool | link | real | int

link = doc_link | rev_link

real = float | double

int = uint8, sint8, unit16, sint16, uint32, sint32, uint64, sint64

dict = 0x00, NoOfElements:32/little, { string, value }

list = 0x10, NoOfElements:32/little, { value }

string = 0x20, StringLength:32/little, ?UTF-8 encoded string?

bool = 0x30, (0x00 | 0x01)

rev_link = 0x40, Rev:128
doc_link = 0x41, Doc:128

float  = 0x50, ?32 bit IEEE float?
double = 0x51, ?64 bit IEEE double?

uint8  = 0x60, ?unsigned char?
sint8  = 0x61, ?signed char?
uint16 = 0x62, ?unsigned short?
sint16 = 0x63, ?signed short?
uint32 = 0x64, ?unsigned long?
sint32 = 0x65, ?signed long?
uint64 = 0x66, ?unsigned long long?
sint64 = 0x67, ?signed long long?

