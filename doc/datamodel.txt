
In Hotchpotch the documents are stored in so called "stores". Each document is
uniquely identified by a (random) UUID, where the document/UUID can
simultaniously live in more than one store. Each store maintains a mapping of
UUIDs to the latest revision of the document (plus zero or more preliminary
revisions). The actual content is stored in revisions and each revision is
identified by the hash of its content.

At the basic level each revision consists of the following:
	- a set of flags
		- the version of the revision data model (currently only version 0)
		- final/preliminary revision
		- possibly other flags in the future
	- a type code, specifying the format of the document (encoded as a Uniform
	  Type Identifier [UTI])
	- a creator code, denoting the application which created the revision
	  (encoded as a reverse-DNS string)
	- the modification time (seconds since epoch, UTC)
	- a list of it's preceeding revision(s) (parents),
	- one or more "parts", each identified by a FourCC and containing a blob.

This basic level is sufficient to store and retrieve arbitrary data, preserve
the history of changes to a document and also replicate and synchronize
documents between multiple stores.

== Binary object representation ==

To compute the hash of a revision a common binary representation is needed.
All values as little endian...

L       .. Flags (0..7: Version, 8:Preliminary)
B       .. PartsCount
{
	4s  .. FourCC
	16s .. MD5 hash of part content
}
B       .. ParentsCount
{
	16s .. Parent object
}
Q       .. Mtime (unix time)
L       .. Type code UTI string length
{s}     .. Type code
L       .. Creator code string length
{s}     .. Creator code


== Well known part FourCCs ==

In Hotchpotch the following part FourCCs have a special meaning:
	- 'META': standardized, extensible meta data
	- 'FILE': byte stream (POSIX file content)
	- 'HPSD': structured content (HotchPotch Structured Data)

The data in 'META' and 'HPSD' is semantically similar to JSON. See below for
its definition and binary representation.


== Document linking ==

Each document is treated completely independent of any other document. For
navigational access of the documents there can be directed links between them.
As entry point to the link chain there is a root document in each store, just
like the root directory in file systems.

There are two types of links in Hotchpotch:
	- Document link: points to a document (which points to the latest revision)
	- Revision link: points to a revision

A document link additionally contains a list of all known revisions of the
document which it refers to at the time the link was created/updated. This is
used when navigating in the history, that is when examining an old revision of
a document.

In essence Hotchpotch links are like symbolic links in the meaning that they
symbolically refer to another document/revision. But they are also like hard links
in the sense that they are independent of the target's location.

== Garbage collection ==

Even though documents and revisions can be deleted explicitly they can also be
garbage collected implicitly. When there is no path from the root document of a
store to the document then it is eligible for garbage collection. The path is
formed by links in the 'HPSD' part and by the parent pointers of each revision.


== Hotchpotch Structured Data ==

The data in the 'HPSD' and 'META' parts of a revision has a defined semantics
and binary representation.

=== Semantics ===

Hotchpotch can represent the following data types:
	- Number
		- Integer: 8..64 bits, signed/unsigned
		- Floating point: float/double
	- String: Unicode, Utf-8
	- Boolean
	- Link
		- Document link
		- Revision link
	- List: ordered sequence of values (any Hotchpotch data type)
	- Dictionary: unordered sequence of key value pairs where
		- the key is a string,
		- and the value is of any Hotchpotch data type

=== Binary representation ===

All data stored as little endian. The following is no strict EBNF but you
should get the idea...

HPSD = value

value = dict | list | string | bool | link | real | int

link = doc_link | rev_link

real = float | double

int = uint8, sint8, unit16, sint16, uint32, sint32, uint64, sint64

dict = 0x00, NoOfElements:32/little, { string, value }

list = 0x10, NoOfElements:32/little, { value }

string = 0x20, StringLength:32/little, ?UTF-8 encoded string?

bool = 0x30, (0x00 | 0x01)

rev_link = 0x40, Rev:128
doc_link = 0x41, Uuid:128, RevCount:8, { Rev:128 }

float  = 0x50, ?32 bit IEEE float?
double = 0x51, ?64 bit IEEE double?

uint8  = 0x60, ?unsigned char?
sint8  = 0x61, ?signed char?
uint16 = 0x62, ?unsigned short?
sint16 = 0x63, ?signed short?
uint32 = 0x64, ?unsigned long?
sint32 = 0x65, ?signed long?
uint64 = 0x66, ?unsigned long long?
sint64 = 0x67, ?signed long long?


== Client interface ==

Hotchpotch clients manipulate documents through a high level API...

=== Information requests ===

enum() -- Enumerate stores

lookup(Doc, Stores) -- Query available document revisions
	Doc: Searched document
	Stores: Optional set of stores where to search. If empty search on all
		mounted stores.

stat(Rev, Stores) -- Get information about a revision
	Rev: Rev to stat
	Stores: Optional set of stores where to search. If empty search on all
		mounted stores.

=== Document manipulation ===

peek(Rev, Stores) -- Open a rev for read only access
	Rev: Rev to open
	Stores: Optional set of stores where to search the rev. If empty search on
		all mounted stores.

create(Type, Creator, Stores) -- Create a new document
	Type: Type UTI of the new document.
	Creator: Reverse DNS identifier of the calling application
	Stores: Optional set of stores where to create the document. If empty
		create on all mounted stores.

fork(Rev, Creator, Stores) -- Create a new document from an existing one
	Rev: Starting Rev of the new document (parent and initial content).
	Creator: Reverse DNS identifier of the calling application
	Stores: Optional set of stores where to search the Rev. If empty try on all
		mounted stores where Rev exists.

update(Doc, Rev, Creator, Stores) -- Update a document
	Doc: Document to be updated
	Rev: Current revision of the document which will be updated. At least one
		store must point to this revision or the operation will fail
		immediately.  Any store which points to another revision will not be
		updated.
	Creator: Optional new creator code. Keep the previous value if left empty
	Stores: Optional set of stores where to update the document. If empty try
		on all mounted stores where Doc exists and is currently pointing to
		Rev.

resume(Doc, Rev, Creator, Stores) -- Resume updating a document
	Doc: Document with a pending preliminary revision
	Rev: A pending preliminary revision of the document
	Creator: Optional new creator code. Keep the previous value if left empty
	Stores: Optional set of stores where to update the document. If empty try
		on all mounted stores where Doc exists and where it has a preliminary
		revision Rev.

read(Handle, Part, Offset, Length)
	Handle: as returned by peek/create/fork/update/resume
	Part: FourCC
	Offset, Length: guess what ;)

write(Handle, Part, Offset, Data)
	Handle: as returned by create/fork/update/resume
	Part: FourCC
	Offset
	Data

trunc(Handle, Part, Offset)
	Handle: as returned by create/fork/update/resume
	Part: FourCC
	Offset

get_parents(Handle) -- Get current parents
	Handle: as returned by create/fork/update/resume

set_parents(Handle, Parents) -- Rebase a document to new parents
	Handle: as returned by create/fork/update/resume
	Parents: New list of parent revisions. Must not be empty.

get_type(Handle) -- Get current type code UTI
	Handle: as returned by create/fork/update/resume

set_type(Handle, Uti) -- Change the type of a document
	Handle: as returned by create/fork/update/resume
	Uti: new Type UTI

commit(Handle) -- Commit changes as new revision of the document
	Handle: as returned by create/fork/update/resume
	Tristate result:
		- success
			- at least one store has commited
		- retry
			- no store has comitted
			- at least one store has rejected due to conflicting revision
		- fail
			- all stores have rejected with hard errors

suspend(Handle) -- Suspend handle and enqueue as preliminary revision
	Handle: as returned by create/fork/update/resume

abort(Handle) -- Discard handle
	Handle: as returned by peek/create/fork/update/resume

=== Data distribution ===

sync(Doc, History, Stores) -- Perform a fast-forward sync
	Doc: Document which should be unified among the stores
	History: Date of oldest revision which should get replicated
	Stores: Optional set of stores where the document is synchronized. If empty
		perform on all stores.

replicate_doc(Doc, Depth, Stores) -- Replicate a document to other stores
	Doc: Document which should be replicated. Must be unambigous throughout
		all involved stores.
	Depth: Date of oldest revision which should get replicated
	Stores: Where to replicate to. If empty replicate to all mounted stores.

replicate_rev(Rev, Depth, Stores) -- Replicate a revision to other stores
	Rev: Revision, must be referenced on the destination stores
	Depth: Date of oldest revision which should get replicated
	Stores: Where to replicate to. If empty replicate to all mounted stores.

forget(Doc, Rev, Stores) -- Dispose a pending preliminary revision
	Doc: Document
	Rev: Pending preliminary revision of the document
	Stores: List of stores where the preliminary revision should be disposed
		from the document. If empty try on all stores.

delete_doc(Doc, Rev, Stores) -- Delete a document
	Doc: Document to be deleted
	Rev: Current revision of the document
	Stores: Optional set of stores where to delete the doc. If empty delete on
		all mounted stores.

delete_rev(Rev, Stores) -- Delete a revision
	Rev: Revision to be deleted
	Stores: Optional set of stores where to delete the rev. If empty delete on
		all mounted stores.

